<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Timer Widget</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    /* ... [CSS unchanged, omitted for brevity] ... */
    /* CSS same as previous version */
  </style>
</head>
<body>
  <h1><i class="fa-solid fa-stopwatch"></i> One Rounds Timer</h1>
  <audio id="alarm-audio" src="https://cdn.pixabay.com/audio/2022/06/15/audio_125b2e2e4d.mp3" preload="auto"></audio>
  <div class="widget-grid" id="timers"></div>
  <script>
    const TIMER_COUNT = 5;
    const billiardNames = [
      'Billiard 1',
      'Billiard 2',
      'Billiard 3',
      'Billiard 4',
      'Billiard 5'
    ];
    let timers = Array.from({length: TIMER_COUNT}, (_, i) => ({
      id: i,
      name: billiardNames[i],
      state: "stopped",
      startTime: null,
      elapsed: 0,
      pauseTime: null,
      date: '',
      time: '',
      duration: 60, // 1 hour is default
      alarmTriggered: false
    }));

    const timerRefs = {};

    function formatDuration(ms) {
      ms = Math.max(ms, 0); // Prevent negative durations
      const sec = Math.floor(ms/1000)%60;
      const min = Math.floor(ms/60000)%60;
      const hr = Math.floor(ms/3600000);
      return `${hr.toString().padStart(2,"0")}:${min.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
    }

    function renderTimers() {
      const grid = document.getElementById('timers');
      grid.innerHTML = '';
      timers.forEach(timer => {
        const widget = document.createElement('div');
        widget.className = 'timer-widget';
        widget.id = `widget-${timer.id}`;

        // Name row
        const nameRow = document.createElement('div');
        nameRow.className = 'timer-name-row';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'timer-name';
        nameSpan.textContent = timer.name;
        nameSpan.setAttribute('data-id', timer.id);
        nameRow.appendChild(nameSpan);

        // Controls
        const controls = document.createElement('div');
        controls.className = 'timer-controls';

        const startBtn = document.createElement('button');
        startBtn.innerHTML = `<i class="fa-solid fa-play"></i>`;
        startBtn.title = timer.state === 'stopped' ? 'Start' : 'Restart';
        startBtn.disabled = (timer.state === 'running');
        startBtn.onclick = () => updateTimerState(timer.id, 'start');

        const pauseBtn = document.createElement('button');
        pauseBtn.innerHTML = timer.state === 'paused'
          ? '<i class="fa-solid fa-play"></i>'
          : '<i class="fa-solid fa-pause"></i>';
        pauseBtn.title = timer.state === 'paused' ? 'Resume' : 'Pause';
        pauseBtn.disabled = (timer.state!=='running' && timer.state!=='paused');
        pauseBtn.onclick = () => updateTimerState(timer.id, 'pause');

        const stopBtn = document.createElement('button');
        stopBtn.innerHTML = '<i class="fa-solid fa-stop"></i>';
        stopBtn.title = 'Stop/Reset';
        stopBtn.disabled = (timer.state === 'stopped');
        stopBtn.onclick = () => updateTimerState(timer.id, 'stop');

        controls.appendChild(startBtn);
        controls.appendChild(pauseBtn);
        controls.appendChild(stopBtn);

        // Timer details
        const details = document.createElement('div');
        details.className = 'timer-details';
        details.innerHTML = `
          <div class="date-time-row">
            <span>
              <strong>Date:</strong>
              <input type="date" id="date-${timer.id}" value="${timer.date}" style="font-size: 1em; padding: 2px 10px; border-radius: 6px; border: 1px solid #FFD700;">
            </span>
            <span>
              <strong>Time:</strong>
              <input type="time" id="time-${timer.id}" value="${timer.time}" style="font-size: 1em; padding: 2px 10px; border-radius: 6px; border: 1px solid #FFD700;">
            </span>
          </div>
          <div class="duration-row">
            <strong>Duration:</strong>
            <select id="duration-${timer.id}" style="font-size: 1em; padding: 2px 10px; border-radius: 6px; border: 1px solid #FFD700;">
              <option value="open">Open</option>
              <option value="30">30 mins</option>
              <option value="60" selected>1 hr</option>
              <option value="90">1.5 hrs</option>
              <option value="120">2 hrs</option>
              <option value="150">2.5 hrs</option>
              <option value="180">3 hrs</option>
              <option value="210">3.5 hrs</option>
              <option value="240">4 hrs</option>
              <option value="270">4.5 hrs</option>
              <option value="300">5 hrs</option>
              <option value="330">5.5 hrs</option>
              <option value="360">6 hrs</option>
              <option value="390">6.5 hrs</option>
              <option value="420">7 hrs</option>
            </select>
          </div>
          <span><strong>Start:</strong> <span id="start-${timer.id}">${timer.startTime ? new Date(timer.startTime).toLocaleTimeString() : '--:--:--'}</span></span>
          <span><strong>Elapsed:</strong> <span class="elapsed" id="elapsed-${timer.id}">${formatDuration(timer.elapsed)}</span></span>
        `;

        widget.appendChild(nameRow);
        widget.appendChild(controls);
        widget.appendChild(details);

        grid.appendChild(widget);

        timerRefs[timer.id] = {
          widget,
          nameSpan,
          startBtn,
          pauseBtn,
          stopBtn,
          start: widget.querySelector(`#start-${timer.id}`),
          elapsed: widget.querySelector(`#elapsed-${timer.id}`),
          dateInput: widget.querySelector(`#date-${timer.id}`),
          timeInput: widget.querySelector(`#time-${timer.id}`),
          durationInput: widget.querySelector(`#duration-${timer.id}`)
        };

        // Editable date/time/duration
        timerRefs[timer.id].dateInput.addEventListener('change', (e) => {
          timers[timer.id].date = e.target.value;
        });
        timerRefs[timer.id].timeInput.addEventListener('change', (e) => {
          timers[timer.id].time = e.target.value;
        });
        timerRefs[timer.id].durationInput.value = timer.duration === "open" ? "open" : timer.duration;
        timerRefs[timer.id].durationInput.addEventListener('change', (e) => {
          if (e.target.value === "open") {
            timers[timer.id].duration = "open";
          } else {
            timers[timer.id].duration = Number(e.target.value);
          }
        });
      });
    }

    function getLocalDateString(dateObj) {
      // Returns YYYY-MM-DD in local time
      return `${dateObj.getFullYear()}-${String(dateObj.getMonth()+1).padStart(2,'0')}-${String(dateObj.getDate()).padStart(2,'0')}`;
    }

    function triggerAlarm(timerId) {
      // Visual shake
      const widget = timerRefs[timerId].widget;
      widget.classList.add('alarm');
      setTimeout(() => widget.classList.remove('alarm'), 1000);

      // Play sound
      const audio = document.getElementById('alarm-audio');
      audio.currentTime = 0; // rewind to start
      audio.play();

      // Notification (if permission)
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("Timer Finished!", { body: timers[timerId].name + " timer is up." });
      }
    }

    // Request permission for notifications when page loads
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }

    function updateTimerState(id, action) {
      const timer = timers[id];
      let changed = false;
      if (action === 'start') {
        timer.state = 'running';
        let now = new Date();
        // If date/time fields are blank, set them to now (using local time, not UTC!)
        if (!timer.date || timer.date.trim() === '') {
          timer.date = getLocalDateString(now);
          timerRefs[id].dateInput.value = timer.date;
        }
        if (!timer.time || timer.time.trim() === '') {
          timer.time = now.toTimeString().slice(0,5); // HH:MM in local time
          timerRefs[id].timeInput.value = timer.time;
        }
        let [year, month, day] = timer.date.split('-').map(Number);
        let [hour, minute] = timer.time.split(':').map(Number);
        let startDateTime = new Date(year, month - 1, day, hour, minute);
        timer.startTime = startDateTime.getTime();
        timer.elapsed = 0;
        timer.pauseTime = null;
        timer.alarmTriggered = false;
        changed = true;
      } else if (action === 'pause') {
        if (timer.state === 'running') {
          timer.state = 'paused';
          timer.pauseTime = Date.now();
          changed = true;
        } else if (timer.state === 'paused') {
          timer.state = 'running';
          if (timer.pauseTime) timer.startTime += (Date.now() - timer.pauseTime);
          timer.pauseTime = null;
          changed = true;
        }
      } else if (action === 'stop') {
        timer.state = 'stopped';
        timer.startTime = null;
        timer.elapsed = 0;
        timer.pauseTime = null;
        timer.date = '';
        timer.time = '';
        timer.duration = 60;
        timer.alarmTriggered = false;
        changed = true;
      }
      if (changed) updateWidgetDOM(id);
    }

    function updateWidgetDOM(id) {
      const t = timers[id];
      const ref = timerRefs[id];
      ref.startBtn.title = t.state === 'stopped' ? 'Start' : 'Restart';
      ref.startBtn.disabled = (t.state === 'running');
      ref.pauseBtn.innerHTML = t.state === 'paused'
        ? '<i class="fa-solid fa-play"></i>'
        : '<i class="fa-solid fa-pause"></i>';
      ref.pauseBtn.title = t.state === 'paused' ? 'Resume' : 'Pause';
      ref.pauseBtn.disabled = (t.state!=='running' && t.state!=='paused');
      ref.stopBtn.disabled = (t.state === 'stopped');
      ref.start.textContent = t.startTime ? new Date(t.startTime).toLocaleTimeString() : '--:--:--';
      ref.elapsed.textContent = formatDuration(t.elapsed);
      ref.nameSpan.textContent = t.name;
      if (ref.dateInput) ref.dateInput.value = t.date;
      if (ref.timeInput) ref.timeInput.value = t.time;
      if (ref.durationInput) ref.durationInput.value = t.duration === "open" ? "open" : t.duration;

      // Set background color based on state
      ref.widget.classList.remove('running', 'paused', 'ending', 'expired');
      if (t.state === 'running') {
        ref.widget.classList.add('running');
      } else if (t.state === 'paused') {
        ref.widget.classList.add('paused');
      }
    }

    function updateElapsedTimes() {
      timers.forEach(timer => {
        const ref = timerRefs[timer.id];
        if (timer.state === 'running') {
          timer.elapsed = Date.now() - timer.startTime;
          // If duration is "open", no limit, no ending/expired/alarm
          if (timer.duration === "open") {
            ref.widget.classList.remove('ending', 'expired');
            // Don't trigger alarm, don't apply 5-min rule
            timer.alarmTriggered = false;
          } else {
            const durationMs = timer.duration * 60 * 1000;
            if (timer.elapsed > durationMs) {
              ref.widget.classList.add('expired');
              ref.widget.classList.remove('ending', 'running');
              // Trigger alarm only once
              if (!timer.alarmTriggered) {
                triggerAlarm(timer.id);
                timer.alarmTriggered = true;
              }
            } else if (durationMs - timer.elapsed <= 5 * 60 * 1000 && timer.elapsed < durationMs) {
              ref.widget.classList.add('ending');
              ref.widget.classList.remove('running', 'expired');
              timer.alarmTriggered = false;
            } else {
              ref.widget.classList.remove('ending', 'expired');
              ref.widget.classList.add('running');
              timer.alarmTriggered = false;
            }
          }
        } else {
          ref.widget.classList.remove('ending', 'expired');
          timer.alarmTriggered = false;
        }
        if (ref && ref.elapsed) {
          ref.elapsed.textContent = formatDuration(timer.elapsed);
        }
      });
    }

    renderTimers();
    setInterval(updateElapsedTimes, 1000);
  </script>
</body>
</html>
